********************************************************************************
*                   Agent-Oriented Programming and Design 2012                 *
*                            Report - Assignment 1                             *
*                        Rhys van der Waerden (s3134601)                       *
********************************************************************************

Exercise 1: Warming Up!
-----------------------

- Step 1:
Already completed during warmup.

- Step 2:
Opened design.pd.

- Step 3:
Exported Player diagram as png. (See player-design.png).

- Step 4:
Added descriptionfor HandlePercept plan.

- Step 5:
Generated JACK code.

- Step 6:
Verified that sources were present and up to date.

- Step 7:
Added to Main.java (line 57):

	System.setProperty("java.util.Arrays.useLegacyMergeSort", "true");

Removed from Makefile (line 17):

	-DJAVACARGS="-target 1.5"

To enabled error free compilation and exectuion under Java 1.7.
As advised I will change to JDK 1.6.

- Summary:
I have learned basic navigation of a PDT project, and how to generate JACK code
and then compile that to Java code. I have also learned how to export diagrams
as PNG files for documentation.

Exercise 2: Knowing where we are
--------------------------------

- Step 1:
Did not add console output, as a similar output was already present in
HandlePercept.plan (line 114):

    consoleIface.showConsoleDebug("A request-action event for step-id " + step
        + "-" + id + " states that " + getAgent().name() +
        " is currently at location " + currentPos.toString() + " with " + items
        + " pieces of gold");

Completing step would simply add redundant output for event. I have not included
the program output as it would be indistinguishable from 'trace1-7.txt'.

- Step 2:
Created new beliefset 'CurrentPosition' for Player.
Fields: int posX, int posY.
Neither fields are keys, as only one position can be "current" for an agent.
The beliefset is #private because each Player has its own unique current
position in the game.


- Step 3:
Generated code successfully.

- Step 4:
Added two queries to CurrentPosition.bel (line 26, just after PDT Design Block):

    #linear query get(logical int posX, logical int posY);
    #linear query check(int posX, int posY);

These queries allow the current position to be retrieved (get) or checked
against supplies integer values (check). The 'logical' arguments on get are
output variables.

As the operation is on a set of exactly one tuple, the queries are linear for
efficiency.

- Step 5:

a: Added link from GamePlaying to bel_currentPosition in Player page in Detailed
Design. This is because current position is updated by the game.

Then within this GamePlaying capability, linked from HandlePercept to
bel_currentPosition.

b: Generate JACK code. Observed new #modifies statement in HandlePercept.plan
(line 39).

        #modifies data CurrentPosition bel_currentPosition_dat;

c. Added code to HandlePercept.plan to update current position beliefset
(line 126):

    // Update beliefset with the current position of the agent
    bel_currentPosition_dat.add(posX, posY);

PROBLEMS:
The first time I attempted this step I added the link from GamePlaying to
bel_currentPosition and then removed it before continuin. This did not remove
bel_currentPosition from within the GamePlaying capability. PDT stopped
working and I had to start again.

- Step 6:
Modify plan ConsoleBeliefPrinting to print out the agent's believed current position.

Added connection from bel_currentPosition to InfoReporting in Player's
GamePlaying capability.

Set bel_currentPosition's modifier to #imports in the InfoReporting diagram.
Added link from bel_currentPosition to ConsoleBeliefPrinting.

Added these lines to the end of body in ConsoleBeliefPrinting.plan (line 85):

        logical int $posX, $posY;
        bel_currentPosition_dat.get($posX, $posY);
        consoleIface.showConsoleDebug("Agent " + getAgent().getName() +
            " believes it is currently at location (" + $posX + "," + $posY +
            ")");

The output can be seen when the program runs (output edited for readability):

[[player6@%portal]] A request-action event for step-id 19-20 states that
                    player6@%portal is currently at location (5, 5) with 0
                    pieces of gold
[[player6@%portal]] Current ID step: 20
[[player6@%portal]] Number of cells believed empty of obstacles: 32
[[player6@%portal]] Number of believed obstructed cells: 2
[[player6@%portal]] Agent player6@%portal believes it is currently at location
                    (5,5)                           <------- THIS THE NEW OUTPUT
[[player6@%portal]] I will move randomly to this dir: down
[[player6@%portal]] I sent CLIMA action *down* for execution with id 20

<Action
    :type  "down"
    :param  "player6@%portal"
    :id  "20"
>

(full output available in trace2-4.txt)

- Summary:
In this exercise I have learned how to:
 - display debug output to console.
 - create a new beliefset.
 - add and retrieve data from a beliefset.
 - interpret and extend the relationship between beliefs and plans in PDT.
 - use version control to prevent losing my progress :)

Exercise 3: Keeping track of gold pieces
----------------------------------------

- Step 1:
CellEmpty is updated by plan UpdateCellsAround. This plan takes an event
'EUpdateBelief' containing a grid coordinate and a list of contents from
its surrounding cells.

At the moment HandlePercept is the only source of EUpdateBelief events, so the
belief updates could be performed within HandlePercept without any change in
behaviour. However, it makes sense to decouple these because later we would
like the agents to benefit from each other's perception.

More specifically, an agent will send an EUpdateBelief to each of its team
mates so that they may know positions of gold, barriers, opponents etc.
When they receive it they will use their "UpdateCellsAround" plan.

- Step 2:
Created data object "bel_goldAt" in Detailed Design -> Player. Modifer is
"#private" because each agent has its own record of perception (for now).

Added data type:
name: GoldAt
fields: int xCoord, int yCoord (both fields are keys, because a different value
must be stored for every unique cell)

- Added connection FROM GamePlaying TO bel_goldAt.

- Within GamePlaying:
  - Added connection FROM UpdateCellsAround TO bel_goldAt.
  - Set modifier of bel_goldAt to #imports.
  - Added connection FROM bel_goldAt TO InfoReporting (for debugging changes).

- Generated Jack successfully!

- Changed belief GoldAt's superclass to OpenWorld (agents will not know the
status of every cell in the game)

a. Added to GoldAt.bel after PDT Design Block (line 26):

    #indexed query checkIfGold(int xCoord, int yCoord);

Parameters are not logical because we are checking against two keys.

b. Added to GoldAt.bel (line 27):

    #indexed query get(logical int xCoord, logical int yCoord);

Since there is no input parameter (both are logical), this will just return any
tuple.

c. Added to GoldAt.bel (line 29):

    #function query public int countGold() {
        logical int $x, $y;
        int count = 0;

        Cursor c = getLocWithGold($x, $y);
        while (c.next()) {
            count++;
        }

        return count;
    }

This function iterates through all tuples/locations in the beliefset,
incrementing a counter whenever a location is believed to have gold.

d. Added to GoldAt.bel (line 41):

    #complex query checkIfGoldInRow(int x) {
        logical int $x, $y;
        return getLocWithGold($x, $y) && (x == $x.as_int());
    }

The return statement of a complex query invokes an implicit next() method on
the Counter objects. The return expression will continue to iterate through all
values returned by getLocWithGold until the && operator returns true or all
tuples are exhausted.

This means that the iteration will continue until a location with gold also
satisfies the expression (x == $x.as_int()), ie. a grid co-ordinate with gold
at row x.

- Step 3:

Changes to design.pd for plans StartSimulation and FinishSimulation to modify
beliefset GoldAt:

- In detailed design of Player:
  - Made connection FROM capability GameSyncing TO bel_goldAt.
- In GameSyncing:
  - Set bel_goldAt's JackCode modifier to #imports.
  - Made connection FROM plan StartSimulation TO bel_goldAt.
  - Made connection FROM plan FinishSimulation TO bel_goldAt.

Generated code and observed line in PDT block of both StartSimulation.plan and
FinishSimulation.plan:

    #modifies data GoldAt bel_goldAt_dat;

Code generation success!

- Code changes:

StartSimulation.plan:
- No changes required, an empty OpenWorld beliefset is constructed with its
  default constructor.
  Since there are no known gold locations before a percept is received, an
  empty beliefset is appropriate.

  I initially tried initialising all tuples to "Cursor.UKNOWN",
  which failed because:

    "Attempts to add tuples with an unknown belief state into a beliefset with
     Open World semantics will cause a BeliefSetException to be thrown."
                                                    -JACK Agent Manual


FinishSimulation.plan (line 62):
- Remove all tuples at the end of simulation, this data has now expired.

    bel_goldAt_dat.getLocWithGold($x,$y).removeAll(); 

  OpenWorldCursor.removeAll() will remove all tuples from the beliefset that
  match the Cursor returned by getLocWithGold(). ie, all the tuples in the
  beliefset.

UpdateCellsAround.play (line 60):
- Update the GoldAt beliefset for each cell:

    // Iterate on all the marks/labels for cells[i]
    for(int j = 0; j < cells[i].marks.length; j++) {
      String cellType = cells[i].marks[j].type;

      // if mark is "unknown" then do not process the cell at all
      if(cellType.equalsIgnoreCase("unknown") == false) {

        if(cellType.equalsIgnoreCase("obstacle")) {

          // This cell contains an obstacle
          bel_cellEmpty_dat.add(loc.x, loc.y, Cursor.FALSE);
        } else {

          // The is considered empty if there is no obstacle
          bel_cellEmpty_dat.add(loc.x, loc.y, Cursor.TRUE);

          // Is there gold in this cell?
          BeliefState hasGold = cellType.equalsIgnoreCase("gold") ?
            Cursor.TRUE : Cursor.FALSE;
          bel_goldAt_dat.add(loc.x, loc.y, hasGold);
        }
      }
    }

  The new line adds a new belief for each cell that is confirmed to either have
  gold or not. ie. any cell that is not unknown or an obstacle.
